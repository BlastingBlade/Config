#+title: Emacs Config
#+PROPERTY: header-args:emacs-lisp :tangle ~/.config/emacs/init.el :mkdirp yes

* Welcome!
Large portions of this config are taken from David Wilson's [[https://github.com/daviwil/emacs-from-scratch][Emacs from Scratch]] series, and [[https://github.com/hlissner/doom-emacs][Doom]] Emacs; huge thanks to these projects!

Some goals of this config include:

- Modernization.
  
  Emacs has a nasty habit of staying in the old times, so large portions of Emacs will be renovated/replaced.

- First Class Programming and Writing.
  
  Emacs already has these goals, but I want more than what ~nano~ provides.
  With the help of ~evil~, ~lsp~, and ~org-mode~, an ideal environment can take shape.

- Transparently comfy.
  
  I will often spend hours on my computer, I should at least find it comfortable.
  Coming from [neo]vim, ~evil~ and evil accessories are an absolute must.
  ~Selectrum~ and other minibuffer enhancements go a long way to accessing Emacs' power.

#+begin_src emacs-lisp :exports none :tangle ~/.config/emacs/init.el
;;; init -- Emacs Configuration
;;; Commentary:
;;; See Config.org
;;; Code:
#+end_src

#+begin_src emacs-lisp :tangle ~/.config/emacs/init.el
(setq user-full-name "Henry Fiantaca"
      user-mail-address "hfiantaca@gmail.com")
#+end_src

* Cleanup
** UI
Emacs has a downright depressing first impression, the first thing to do is clean up the default layout.

#+begin_src emacs-lisp :tangle ~/.config/emacs/init.el
(setq visible-bell t)
(scroll-bar-mode -1)
(tool-bar-mode -1)
(tooltip-mode -1)
(menu-bar-mode -1)
(set-fringe-mode 0)
#+end_src

** Transient Cruft
Emacs (and it's packages) have a nasty habit of leaving tons of "transient" files all over the place.

Much of this should be collected in cache, _NOT_ configuration.

#+begin_src emacs-lisp :tangle ~/.config/emacs/init.el
;; Keep transient cruft with the rest of my transient cruft
(defvar state-emacs-directory "~/.local/lib/emacs/"
  "Directory to store state files and data.
  Anything that is downloaded for or created by the config goes here.
  Packages, project index, etc.")

(defvar config-emacs-directory user-emacs-directory
  "Directory that stores the emacs configuration.
  Mostly tangled from org files.")

(setq user-emacs-directory "~/.cache/emacs/"
      backup-directory-alist `(("." . ,(expand-file-name "backups" user-emacs-directory)))
      auto-save-list-file-prefix (expand-file-name "auto-save-list/.saves-" user-emacs-directory))

(make-directory user-emacs-directory t)

;; Keep customization settings in a temporary file (thanks Ambrevar!)
(setq custom-file
      (if (boundp 'server-socket-dir)
          (expand-file-name "custom.el" server-socket-dir)
        (expand-file-name (format "emacs-custom-%s.el" (user-uid)) temporary-file-directory)))
(load custom-file t)
#+end_src

** Startup
Also quiet down the startup process.

The Emacs startup message isn't really worth the load times, the message in the scratch buffer isn't necessary, and by setting the scratch buffer to fundamental-mode can save seconds on package loading.

#+begin_src emacs-lisp :tangle ~/.config/emacs/init.el
(setq inhibit-startup-message t
      inhibit-startup-echo-area-message user-login-name
      inhibit-default-init t
      initial-major-mode 'fundamental-mode
      initial-scratch-message nil
      find-file-suppress-same-file-warnings t)
#+end_src

** Autosaving
And too cleanup the temp files kept while editing.

Resolving simlinks before visiting a file can prevent later problems.
Lockfiles and backups are so last century, autosaving is a much more sane crash-recovery system.

#+begin_src emacs-lisp :tangle ~/.config/emacs/init.el
(setq find-file-visit-truename t ;; resolve simlinks
      vc-follow-symlinks t
      create-lockfiles nil ;; unnessisary temp files
      make-backup-files nil
      auto-save-default t ;; enable a modern solution, autosave
      auto-save-include-big-deletions t
      auto-save-list-file-prefix (concat user-emacs-directory "auto-save/")
      ;; custom var, move TRAMP config to a use-package?
                                        ;tramp-auto-save-directory (concat user-emacs-directory "auto-save/tramp/"))
      )
#+end_src

* Package Manager
Because of the way Doom makes use of ~straight.el~ I thought I'd give it a swing, and I'm quite liking it.
Straight even integrates with ~use-package~, which sure makes life easier.

Straight's base dir, (where =straight/{repo,build}= is put) should be in the state dir, and this dir should be made.

#+begin_src emacs-lisp :tangle ~/.config/emacs/init.el
(setq straight-base-dir state-emacs-directory
      straight-use-package-by-default t)

(make-directory straight-base-dir t)

;; Bootstrap Straight.el
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" straight-base-dir))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))

(straight-use-package 'use-package)
#+end_src

Installing async for byte compilation.
#+begin_src emacs-lisp
(use-package async
  :init
  (async-bytecomp-package-mode 1))
#+end_src

** Hacks
- Org-Mode
  I cannot trust the built-in Org to not be loaded out-of-turn, so it has to be first.

#+begin_src emacs-lisp
(straight-use-package 'org-plus-contrib)
#+end_src

* Core Editor
** Evil
Let's get _Evil_!

#+begin_src emacs-lisp
(use-package evil
  :demand t
  :custom
  (evil-want-integration t)
  (evil-want-keybinding nil)
  (evil-want-C-u-scroll t)
  (evil-split-window-below t)
  (evil-respect-visual-line-mode t)
  (evil-undo-system 'undo-tree)
  :init
  (straight-use-package 'undo-tree)
  (global-undo-tree-mode 1)
  :config
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)
  (evil-mode 1)
  (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state)
  (define-key evil-insert-state-map (kbd "C-h") 'evil-delete-backward-char-and-join)

  ;; use emacs state in some buffers
  (dolist (mode '(custom-mode
                  eshell-mode
                  shell-mode
                  term-mode
                  vterm-mode))
    (add-to-list 'evil-emacs-state-modes mode))

  (evil-set-initial-state 'messages-buffer-mode 'normal)
  (evil-set-initial-state 'dashboard-mode 'normal))
#+end_src

There are many of us on the dark-side, a collection of the evil ways is maintained by and for the collective.

#+begin_src emacs-lisp
(use-package evil-collection
  :demand t
  :after evil
  :config
  (evil-collection-init))
#+end_src

And some good +vim+ evil plugins.

#+begin_src emacs-lisp
(use-package evil-anzu
  :after evil)

(use-package evil-nerd-commenter
  :bind ("M-/" . evilnc-comment-or-uncomment-lines))

(use-package evil-surround
  :config
  (global-evil-surround-mode 1))
#+end_src

** Which-Key
Little configuration needed, I just want to see what I'm doing sometimes.

#+begin_src emacs-lisp
(use-package which-key
  :init (which-key-mode 1)
  :diminish which-key-mode
  :custom
  (which-key-idle-delay 1))
#+end_src

** General
 Here come the General! 

General makes binding keys and keymaps a breeze.
- TODO there's some integration with use-package in general now, I need to look into that

#+begin_src emacs-lisp
(use-package general
  :config
  (general-evil-setup t)

  (general-create-definer blast/leader
    :keymaps '(normal insert visual emacs)
    :prefix "SPC"
    :global-prefix "C-SPC")

  (defun blast/find-file-config-org ()
    "Open Config.org via `find-file'."
    (find-file (expand-file-name "Config.org" config-emacs-directory)))

  (blast/leader
    "f"  '(:ignore t :which-key "files")
    "t"  '(:ignore t :which-key "toggles")
    "o" '(:ignore t :which-key "open")

    "tt" '(load-theme :which-key "choose theme")
    "ff" '(find-file :which-key "find-file")
    "fp" '(blast/find-file-config-org :which-key "emacs config")))
#+end_src

** Transient Keymaps
Hydra provides a simple way to create and invoke transient keymaps.

#+begin_src emacs-lisp
(use-package hydra)
#+end_src

** Modernization
Emacs needs modernization. Bad.

When opening a file, I should be prompted to create the directory.
Not notified to suggest that I may want to create the directory at some point I guess.
#+begin_src emacs-lisp
(defun doom-create-missing-directories-h ()
  "Automatically create missing directories when creating new files."
  (unless (file-remote-p buffer-file-name)
    (let ((parent-directory (file-name-directory buffer-file-name)))
      (and (not (file-directory-p parent-directory))
           (y-or-n-p (format "Directory `%s' does not exist! Create it? "
                             parent-directory))
           (progn (make-directory parent-directory 'parents)
                  t)))))
(add-hook 'find-file-not-found-functions #'doom-create-missing-directories-h)
#+end_src

New file buffers default to ~fundamental-mode~, so Emacs should try to find a more appropriate mode for these buffers.
#+begin_src emacs-lisp
(defun doom-guess-mode-h ()
  "Guess mode when saving a file in `fundamental-mode'."
  (when (eq major-mode 'fundamental-mode)
    (let ((buffer (or (buffer-base-buffer) (current-buffer))))
      (and (buffer-file-name buffer)
           (eq buffer (window-buffer (selected-window))) ; only visible buffers
           (set-auto-mode)))))
(add-hook 'after-save-hook #'doom-guess-mode-h)
#+end_src

Unless set otherwise, spaces have won the indentation war.
Default all modes to 4 space tabs for indentations.
#+begin_src emacs-lisp
(setq-default indent-tabs-mode nil
              tab-width 4)
#+end_src

Wrap words without breaking them unnecessarily, but only with ~visual-line-mode~ or ~auto-fill-mode~ to avoid expensive wrapping.
Text-mode should have soft-wrapping (~visual-line-mode~) enabled by default.
#+begin_src emacs-lisp
(setq-default fill-column 80
              word-wrap t
              truncate-lines t)
(setq truncate-partial-width-windows nil)

(add-hook 'text-mode-hook #'visual-line-mode)
#+end_src

** Emacs-Lisp

#+begin_src emacs-lisp
;; Is Ivy/Counsel really a dependency of this?!
(use-package lispy
  :disabled
  :hook (emacs-lisp-mode . lispy-mode))

(use-package lispyville
  :disabled
  :hook (lispy-mode . lispyville-mode)
  :config
  (lispy-set-key-theme '(lispy c-digits)))
#+end_src

* UI
Now that we can install packages, it's time to set up the UI for real!

** Icons
Icons make acting at-a-glance doable. All-the-Icons makes icons doable.

Note: icons need to be installed by running =M-x all-the-icons-install-fonts=.
- TODO find a reliable way to test for the fonts, and run the installer in their absence in ~:config:~

#+begin_src emacs-lisp
(use-package all-the-icons)
#+end_src

** Doom Modeline
If I wanted the basic default modeline, I'd have stuck with vim.
Doom's modeline is sleek, modern, beautiful. *I want it.*

#+begin_src emacs-lisp
(use-package doom-modeline
  :init (doom-modeline-mode 1)
  :custom (doom-modeline-height 32))
#+end_src

** Theme
Doom's themes make life in Emacs worth living. Especially since the default Emacs theme is just a pure white box.
Doom themes can also move the visual bell to the modeline! Great stuff!

#+begin_src emacs-lisp
(use-package doom-themes
  :custom
  (doom-themes-enable-bold t)
  (doom-themes-enable-italic t)
  :init
  (load-theme 'doom-palenight t)
  (doom-themes-visual-bell-config)
  (doom-themes-org-config))
#+end_src

** Fonts
- Fira Code is a delightful font family to program with, and thus my default/fixed-pitch font of choice.
- Cantarell is a nice font for everything outside of programming, and thus my variable-pitch font of choice.

Note: ~:height~ is in 1/10th of a pt.
#+begin_src emacs-lisp
(set-face-attribute 'default nil :font "Fira Code Retina" :height 120 :width 'condensed)
(set-face-attribute 'fixed-pitch nil :font "Fira Code Retina" :height 120 :width 'condensed)
(set-face-attribute 'variable-pitch nil :font "Cantarell" :height 120 :weight 'regular)
#+end_src

** Frames
By "Frames" Emacs means "windows."

#+begin_src emacs-lisp
;; Only transparent, fullscreen frames count
(set-frame-parameter (selected-frame) 'alpha '(90 . 75))
(add-to-list 'default-frame-alist '(alpha . (90 . 75)))
#+end_src

** Solaire

Makes file buffers and virtual buffers distinct. Looks great!
#+begin_src emacs-lisp
(use-package solaire-mode
  :init
  (solaire-global-mode))
#+end_src
Praise the Sun!

** Parentheses
Especially in LISPs, I need pretty colors to keep my eyes from glassing over all the parentheses.

#+begin_src emacs-lisp
(use-package paren
  :config
  (show-paren-mode 1))

(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

** Line Numbers
Not super useful all the time, it makes programming feel more official somehow.

Also hooks a disable function for modes that don't play well with line numbers, like images, shells and Org mode.
#+begin_src emacs-lisp
(global-hl-line-mode 1)

(column-number-mode)
(global-display-line-numbers-mode t)

(defun blast/disable-line-numbers-mode ()
  "Helper to disable `display-line-numbers-mode'.
  Useful for creating hooks."
  (display-line-numbers-mode 0))
(dolist (mode '(org-mode-hook
                treemacs-mode-hook
                eshell-mode-hook
                shell-mode-hook
                term-mode-hook
                vterm-mode-hook
                image-mode-hook))
  (add-hook mode #'blast/disable-line-numbers-mode))

(use-package visual-fill-column)
#+end_src

** Sidebar

#+begin_src emacs-lisp
(use-package treemacs-all-the-icons)
(use-package treemacs-evil)
#+end_src

* Minibuffer
By bothering with the mini-buffer, Emacs can find true power.

** Selectrum

Incrementally, vertical completion, like from Ivy, but by and for cool kids.

#+begin_src emacs-lisp
(use-package selectrum
  :bind (("C-x C-z" . selectrum-repeat)
         :map selectrum-minibuffer-map
         ("C-j" . selectrum-next-candidate)
         ("C-k" . selectrum-previous-candidate))
  :config
  (selectrum-mode))
#+end_src

** Prescient

Completion filtering, now with regex and initials!

#+begin_src emacs-lisp
(use-package prescient
  :config
  (prescient-persist-mode))

(use-package selectrum-prescient
  :config
  (selectrum-prescient-mode))
#+end_src

** Marginalia

Marginalia (the word) refers to the marks and annotations written in the margins of a page.
Marginalia (the package) adds docstrings to items in the minibuffer completion window.

#+begin_src emacs-lisp
(use-package marginalia
  :straight (marginalia :type git :host github :repo "minad/marginalia" :branch "main")
  :bind (:map minibuffer-local-map
              ("C-M-a" . marginalia-cycle))
  :init
  (marginalia-mode)

  (advice-add #'marginalia-cycle :after
              (lambda () (when (bound-and-true-p selectrum-mode) (selectrum-exhibit))))
  (setq marginalia-annotators '(marginalia-annotators-heavy marginalia-annotators-light nil)))
#+end_src

** Embark

Emacs Minibuffer Actions Rooted in Keymaps

#+begin_src emacs-lisp
(defun embark/selectrum-refresh ()
  "Force Selectrum to refresh content."
  (setq selectrum--previous-input-string nil))

(defun current-candidate+category ()
  (when selectrum-active-p
    (cons (selectrum--get-meta 'category)
          (selectrum-get-current-candidate))))
(defun current-candidates+category ()
  (when selectrum-active-p
    (cons (selectrum--get-meta 'category)
          (selectrum-get-current-candidates
           ;; Pass relative file names for dired.
           minibuffer-completing-file-name))))

(use-package embark
  :straight (embark :type git :host github :repo "oantolin/embark")
  :hook
  (embark-pre-action . embark/selectrum-refresh)
  (embark-target-finders . current-candidate+category)
  (embark-candidate-collectors . current-candidates+category)
  (embark-setup-hook . selectrum-set-selected-candidate)
  :init
  ;; enable which-key for Embark popups
  (setq embark-action-indicator
        (lambda (map)
          (which-key--show-keymap "Embark" map nil nil 'no-paging)
          #'which-key--hide-popup-ignore-command)
        embark-become-indicator embark-action-indicator))
#+end_src

** Consult

#+begin_src emacs-lisp
(use-package consult
  :straight (consult :type git :host github :repo "minad/consult" :branch "main")
  :bind (("C-x M-:" . consult-complex-command)
         ("C-c h" . consult-history)
         ("C-c m" . consult-mode-command)
         ("C-x b" . consult-buffer)
         ("C-x 4 b" . consult-buffer-other-window)
         ("C-x 5 b" . consult-buffer-other-frame)
         ("C-x r x" . consult-register)
         ("C-x r b" . consult-bookmark)
         ("M-g g" . consult-goto-line)
         ("M-g M-g" . consult-goto-line)
         ("M-g o" . consult-outline)     ;; "M-s o" is a good alternative.
         ("M-g l" . consult-line)        ;; "M-s l" is a good alternative.
         ("M-g m" . consult-mark)        ;; I recommend to bind Consult navigation
         ("M-g k" . consult-global-mark) ;; commands under the "M-g" prefix.
         ("M-g i" . consult-imenu)
         ("M-g e" . consult-error)
         ("M-s m" . consult-multi-occur)
         ("M-y" . consult-yank-pop)
         ("<help> a" . consult-apropos))
  :init
  (fset 'multi-occur #'consult-multi-occur)
  :config

  ;; Optionally configure narrowing key.
  ;; Both < and C-+ work reasonably well.
  (setq consult-narrow-key "<") ;; (kbd "C-+")
  ;; Optionally make narrowing help available in the minibuffer.
  ;; Probably not needed if you are using which-key.
  ;; (define-key consult-narrow-map (vconcat consult-narrow-key "?") #'consult-narrow-help)

  ;; Optional configure a view library to be used by `consult-buffer'.
  ;; The view library must provide two functions, one to open the view by name,
  ;; and one function which must return a list of views as strings.
  ;; Example: https://github.com/minad/bookmark-view/
  ;; (setq consult-view-open-function #'bookmark-jump
  ;;       consult-view-list-function #'bookmark-view-names)

  ;; Optionally enable previews. Note that individual previews can be disabled
  ;; via customization variables.
  (consult-preview-mode))

(use-package consult-selectrum
  :demand t)

(use-package consult-flycheck
  :bind (:map flycheck-command-map
              ("!" . consult-flycheck)))
#+end_src

* Helpful
Emacs has a really good documentation culture, good thing there's a /Helpful/ way to make use of them.

#+begin_src emacs-lisp
(use-package helpful
  :custom
  (counsel-describe-function-function #'helpful-callable)
  (counsel-describe-variable-function #'helpful-variable)
  :bind
  ([remap describe-function] . helpful-function)
  ([remap describe-command] . helpful-command)
  ([remap describe-variable] . helpful-variable)
  ([remap describe-key] . helpful-key)
  :config
  (blast/leader
    "h"  '(:ignore t :which-key "help")
    "hv" '(helpful-variable :which-key "variable doc")
    "hf" '(helpful-function :which-key "function doc")
    "hF" '(helpful-macro    :which-key "macro doc")
    "hs" '(helpful-symbol   :which-key "symbol doc")
    "hm" '(describe-mode    :which-key "mode doc")
    "hl" '(helpful-at-point :which-key "doc at point")))
#+end_src

* Credentials
GNU Pass in Emacs? Yes please!

#+begin_src emacs-lisp
(use-package pass
  :config
  (blast/leader
    "op" '(:ignore t :which-key "pass")
    "opp" '(pass :which-key "pass menu")
    "opr" '(password-store-copy :which-key "pass retrive")
    "opi" '(password-store-insert :which-key "pass insert")
    "opg" '(password-store-generate :which-key "pass generate")))

(use-package auth-source-pass
  :straight `(auth-source-pass :type built-in)
  :custom
  (auth-sources '("~/.config/authinfo.gpg"))
  :config
  (auth-source-pass-enable))

#+end_src

** EPG Pinentry
Emacs can act as the pinentry agent, making PGP protected files and the password-store transparent

#+begin_src emacs-lisp
  (use-package pinentry
    :custom
    (epa-pinentry-mode 'loopback)
    :config
    (pinentry-start))
#+end_src

* Projects
Using Projectile and Magit, project management is easy mode.

** Perspective
#+begin_src emacs-lisp
(use-package perspective
  :init (persp-mode))

(use-package treemacs-perspective
  :after perspective treemacs
  :config (treemacs-set-scope-type 'Perspectives))
#+end_src

** Projectile
Map project commands under ~C-c p~, and index all my =~/Projects=.
#+begin_src emacs-lisp
(use-package projectile
  :diminish projectile-mode
  :config (projectile-mode)
  :custom
  (projectile-known-projects-file (expand-file-name "projectile-bookmarks.eld" user-emacs-directory))
  :bind-keymap
  ("C-c p" . projectile-command-map) ;; TODO: which-key "Projects"
  :init
  (blast/leader
    "p" '(:keymap projectile-command-map :package projectile :which-key "projectile"))
  (when (file-directory-p "~/Projects")
    (setq projectile-project-search-path '("~/Projects")))
  (setq projectile-switch-project-action #'projectile-dired))
#+end_src

*** IBuffer
IBuffer can be made to recognize projects and filter for those buffers

#+begin_src emacs-lisp
(use-package ibuffer-projectile
  :hook (ibuffer . ibuffer-projectile-set-filter-groups)
  :config
  (setq ibuffer-projectile-prefix
        (concat (all-the-icons-octicon
                 "file-directory"
                 :face ibuffer-filter-group-name-face
                 :v-adjust -0.05)
                " ")))
#+end_src

*** Sidebar
#+begin_src emacs-lisp
(use-package treemacs-projectile)
#+end_src

** Magit
Magic Git!

#+begin_src emacs-lisp
(use-package magit)

;; Some error with 'k'
;(use-package evil-magit
;  :after magit)
#+end_src

*** Forge
Git{hub,lab} integration with Magit

- Note: may ask to build/install SQLite binary, either allow or disable forge
- Note: forge needs an access token for GHub package
#+begin_src emacs-lisp
(use-package forge
  :after magit)
#+end_src

* Emacs as an OS

** Shells and Terminals
EShell is still a bit odd, but offers powerful integration.

Solution: Install and use EShell and VTerm for the best of both!
*** EShell

#+begin_src emacs-lisp
(use-package eshell
  :straight `(eshell :type built-in) ;; is this the best way to do this?
  :custom
  (eshell-banner-message "Emacs OS Ready:\n\n")
  (eshell-aliases-file "~/.config/emacs/aliases.eshell")
  (eshell-scroll-to-bottom-on-input 'all)
  (eshell-kill-processes-on-exit t)
  (eshell-destroy-buffer-when-process-dies t)
  (eshell-visual-commands '("screen"
                            "tmux"
                            "top"
                            "htop"
                            "lynx"
                            "links"
                            "ncftp"))
  (eshell-hist-ignoredups t)
  (eshell-input-filter #'eshell-input-filter-initial-space)
  :hook
  (eshell-mode . (lambda ()
                   (rainbow-delimiters-mode)
                   (set-window-fringes nil 0 0)
                   (set-window-margins nil 1 nil)
                   (visual-line-mode +1))))

(use-package eshell-syntax-highlighting
  :hook (eshell-mode . eshell-syntax-highlighting-mode))

(use-package bash-completion)

(use-package fish-completion
  :hook (eshell-mode . fish-completion-mode)
  :init (setq fish-completion-fallback-on-bash t))
#+end_src

The biggest thing I dislike about eshell is the prompt, and I really like powerline.
#+begin_src emacs-lisp
(use-package eshell-git-prompt
  :after eshell
  :config (eshell-git-prompt-use-theme 'powerline))
#+end_src

*** VTerm
#+begin_src emacs-lisp
(use-package vterm
  :disabled)
#+end_src

** Dired
Emacs' File manager

*** Ranger
I prefer ranger though, so let's install that!
#+begin_src emacs-lisp
(use-package ranger
  :after dired
  :disabled
  :init (setq ranger-override-dired t)
  :custom
  (ranger-cleanup-eagerly t)
  (ranger-excuded-extensions '("mkv" "iso" "mp4"))
  (ranger-deer-show-details t)
  (ranger-max-preview-size 10)
  (ranger-show-literal nil)
  (ranger-hide-cursor nil))
#+end_src

*** Icons
File managers are the best place for icons to show off.
#+begin_src emacs-lisp
(use-package all-the-icons-dired
  :hook (dired-mode . all-the-icons-dired-mode))
#+end_src

*** TODO Added stuff
- I want to be able to update my wallpaper by pointing Dired at a picture, press W, and have it update.
#+begin_src emacs-lisp :tangle no
  ;;;; UNFINISHED!!!!

(defun blast/wallpaper-find-file (&optional file-name)
  "Update and set the wallpaper to the selected file in dired.
  Can only update the wallpaper while EXWM is loaded"

  (setq file-name (expand-file-name file-name))
  ;; run ~convert~ to copy input file to $DOOMDIR/exwm/wallpaper.png

  ;; call if-exists
  (when (functionp blast/randr-update)
    (blast/randr-update)))
#+end_src

** IBuffer
Especially in EXWM, IBuffer is a good way to quickly manage buffers.

#+begin_src emacs-lisp
(use-package ibuffer
  :straight `(ibuffer :type built-in)
  :custom
  (ibuffer-show-empty-filter-groups nil)
  (ibuffer-filter-group-name-face '(:inherit (success bold))))

(use-package all-the-icons-ibuffer
  :config
  (all-the-icons-ibuffer-mode 1))
#+end_src

** EAF

#+begin_src emacs-lisp
(use-package eaf
  :disabled
  :straight (eaf :type git
                 :host github
                 :repo "manateelazycat/emacs-application-framework"
                 :files ("*.el" "*.py" "core" "app"))
  :custom
                                        ;  (eaf-browser-dark-mode "true")
                                        ;  (eaf-terminal-dark-mode "true")
                                        ;  (eaf-mindmap-dark-mode "true")
                                        ;  (eaf-pdf-dark-mode "true")
  (eaf-browser-continue-where-left-off t)
  (eaf-browser-enable-adblocker "true")
  (eaf-browser-default-search-engine "duckduckgo")
  (eaf-browser-blank-page-url "https://start.duckduckgo.com")
  :config
  (setq browse-url-browser-function 'eaf-open-browser)
  (defalias 'bowse-web #'eaf-open-browser))

(use-package eaf-evil
  :after eaf
  :straight eaf)
#+end_src

* Programming
The reason we're all here, to program.

First, ~lsp-mode~ will be set up to facilitate advanced language support, and ~dap-mode~ for advanced debugging.
Then modes for each languages' will be installed and configured.

** Language Support Protocol

#+begin_src emacs-lisp
(use-package lsp-mode
  :hook
  (before-save . lsp-format-buffer)
  (lsp-mode . lsp-modeline-diagnostics-mode)
  (lsp-mode . lsp-modeline-code-actions-mode)
  (lsp-mode . lsp-headerline-breadcrumb-mode)
  :commands (lsp lsp-deferred)
  :init
  (setq lsp-keymap-prefix "C-c l")
  :custom
  (lsp-idle-delay 0.1)
  (lsp-enable-which-key-integration t)
  (lsp-modeline-diagnostics-scope :workspace)
  (lsp-modeline-code-actions-segments '(name icon))
  (lsp-headerline-breadcrumb-segments '(path-up-to-project file symbols))
  (lsp-diagnostic-package :flycheck)
  (lsp-prefer-capf t)
  (read-process-output-max (* 1024 1024))
  (lsp-session-file (concat state-emacs-directory "lsp-session"))
  (lsp-server-install-dir (concat state-emacs-directory "lisp/"))
  (lsp-rust-server 'rust-analyzer))

(use-package lsp-ui
  :custom
  (lsp-ui-doc-max-width 80)
  (lsp-ui-doc-position 'at-point))

(use-package lsp-treemacs)

(defun blast/ide ()
  "Launch supplementary buffers and tools.
  One-time run, makes use of an `lsp' buffer and starts `lsp-treemacs'."
  (interactive)
  (lsp-treemacs-symbols)
  (lsp-treemacs-errors-list)
  ;; TODO: fix treemacs
                                        ;(treemacs)
  )
#+end_src

Use flycheck to visualize code issues in real time.
#+begin_src emacs-lisp
  (use-package flycheck
    :init (global-flycheck-mode))
#+end_src

Use company to provide completion-at-point.
#+begin_src emacs-lisp
  (use-package company
    :init (global-company-mode)
    :custom
    (company-idle-delay 0.0)
    (company-minimum-prefix-length 1)
    (company-tooltip-align-annotations t)
    (company-tooltip-limit 10)
    (company-require-match 'never)
    (company-backends '(company-capf)))

  (use-package company-box
    :hook (company-mode . company-box-mode))

  (use-package company-posframe
    :config
    (company-posframe-mode)
    :custom
    (company-posframe-quickhelp-delay nil))
#+end_src

** Debugger Adapter Protocol

#+begin_src emacs-lisp
(use-package dap-mode)
#+end_src
** C/C++ (CLangd) (LLDB)

#+begin_src emacs-lisp
(require 'dap-gdb-lldb)
(add-hook 'c-mode-hook 'lsp)
(add-hook 'cpp-mode-hook 'lsp)
#+end_src

** Rust (RLS)

#+begin_src emacs-lisp
(use-package cargo
  :hook (rust-mode . cargo-minor-mode)
  (rust-mode . lsp))
(use-package toml-mode)
#+end_src

* Org Mode
Everything seems to have a killer app, Org-Mode is Emacs' killer app.

Org is a real messy package though.
In the [[*Package Manager]] section, Org was pre-loaded to avoid having the built-in Org load in and cause havoc.

#+begin_src emacs-lisp :noweb no-export
<<org-fonts>>
<<org-buffer-modes>>
<<org-center-buffers>>
<<org-keyfun>>
<<org-auto-tangle>>

(use-package org
  :straight org-plus-contrib
  :hook
  (org-mode . blast/org-mode-setup)
  (org-mode . efs/org-mode-visual-fill)
  (org-mode . (lambda () (add-hook 'after-save-hook #'efs/org-babel-tangle-config)))
  :bind (:map org-mode-map
              <<org-keymap>>)
  :custom
  (org-ellipsis " ▾ ")
  (org-agenda-start-with-log-mode t)
  (org-log-done 'time)
  (org-log-into-drawer t)
  (org-src-preserve-indentation t)
  <<org-export-latex-custom>>

  :config
  (require 'org-habit)
  (add-to-list 'org-modules 'org-habit)

  <<org-agenda-config>>
  <<org-export-hugo-config>>
  <<org-export-pandoc-config>>
  <<org-export-groff-config>>

  <<org-babel-config>>

  (define-key global-map (kbd "C-c j")
    (lambda () (interactive) (org-capture nil "jj")))

  (blast/org-font-setup))
#+end_src

** Fonts

#+name: org-fonts
#+begin_src emacs-lisp :tangle no
(defun blast/org-font-setup ()
  "Set face sizes for heading levels."
  (dolist (face '((org-level-1 . 1.5)
                  (org-level-2 . 1.4)
                  (org-level-3 . 1.3)
                  (org-level-4 . 1.2)
                  (org-level-5 . 1.1)
                  (org-level-6 . 1.1)
                  (org-level-7 . 1.1)
                  (org-level-8 . 1.1)))
    (set-face-attribute (car face) nil :font "Cantarell" :height (cdr face)))

  ;; Ensure that anything that should be fixed-pitch in Org files appears that way
  (set-face-attribute 'org-block nil :foreground nil :inherit 'fixed-pitch)
  (set-face-attribute 'org-code nil   :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-table nil   :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-verbatim nil :inherit '(shadow fixed-pitch))
  (set-face-attribute 'org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
  (set-face-attribute 'org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
  (set-face-attribute 'org-checkbox nil :inherit 'fixed-pitch))
#+end_src

** Buffer Modes

#+name: org-buffer-modes
#+begin_src emacs-lisp :tangle no
(defun blast/org-mode-setup ()
  "Org-Mode setup callback."
  (org-indent-mode)
  (variable-pitch-mode 1)
  (visual-line-mode 1))
#+end_src

** Center Buffers
Visual fill centers the content of Org buffers, making life better.

#+name: org-center-buffers
#+begin_src emacs-lisp :tangle no
(defun efs/org-mode-visual-fill ()
  "Center an Org-Mode buffer and wrap the text."
  (setq visual-fill-column-width 100
        visual-fill-column-center-text t)
  (visual-fill-column-mode 1))
#+end_src

** Keymap

#+name: org-keymap
#+begin_src emacs-lisp :tangle no
("S-RET"      . +org/shift-return)
("C-RET"      . +org/insert-item-below)
("C-S-RET"    . +org/insert-item-above)
("C-M-RET"    . org-insert-subheading)
([C-return]   . +org/insert-item-below)
([C-S-return] . +org/insert-item-above)
([C-M-return] . org-insert-subheading)
#+end_src

#+name: org-keyfun
#+begin_src emacs-lisp :tangle no
(defun +org--insert-item (direction)
  "Insert a new item or heading in DIRECTION 'above or 'below in the tree.

  Stolen from Doom Emacs."
  (let ((context (org-element-lineage
                  (org-element-context)
                  '(table table-row headline inlinetask item plain-list)
                  t)))
    (pcase (org-element-type context)
      ;; Add a new list item (carrying over checkboxes if necessary)
      ((or `item `plain-list)
       ;; Position determines where org-insert-todo-heading and org-insert-item
       ;; insert the new list item.
       (if (eq direction 'above)
           (org-beginning-of-item)
         (org-end-of-item)
         (backward-char))
       (org-insert-item (org-element-property :checkbox context))
       ;; Handle edge case where current item is empty and bottom of list is
       ;; flush against a new heading.
       (when (and (eq direction 'below)
                  (eq (org-element-property :contents-begin context)
                      (org-element-property :contents-end context)))
         (org-end-of-item)
         (org-end-of-line)))

      ;; Add a new table row
      ((or `table `table-row)
       (pcase direction
         ('below (save-excursion (org-table-insert-row t))
                 (org-table-next-row))
         ('above (save-excursion (org-shiftmetadown))
                 (+org/table-previous-row))))

      ;; Otherwise, add a new heading, carrying over any todo state, if
      ;; necessary.
      (_
       (let ((level (or (org-current-level) 1)))
         ;; I intentionally avoid `org-insert-heading' and the like because they
         ;; impose unpredictable whitespace rules depending on the cursor
         ;; position. It's simpler to express this command's responsibility at a
         ;; lower level than work around all the quirks in org's API.
         (pcase direction
           (`below
            (let (org-insert-heading-respect-content)
              (goto-char (line-end-position))
              (org-end-of-subtree)
              (insert "\n" (make-string level ?*) " ")))
           (`above
            (org-back-to-heading)
            (insert (make-string level ?*) " ")
            (save-excursion (insert "\n"))))
         (when-let* ((todo-keyword (org-element-property :todo-keyword context))
                     (todo-type    (org-element-property :todo-type context)))
           (org-todo
            (cond ((eq todo-type 'done)
                   ;; Doesn't make sense to create more "DONE" headings
                   (car (+org-get-todo-keywords-for todo-keyword)))
                  (todo-keyword)
                  ('todo)))))))

    (when (org-invisible-p)
      (org-show-hidden-entry))
    (when (and (bound-and-true-p evil-local-mode)
               (not (evil-emacs-state-p)))
      (evil-insert 1))))

(defun +org/shift-return (&optional arg)
  "Insert a literal newline, or dwim in tables.
  Executes `org-table-copy-down' if in table.

  Optional ARG is passed as universal operator to `org-table-copy-down' or `org-return'.
  Stolen from Doom Emacs."
  (interactive "p")
  (if (org-at-table-p)
      (org-table-copy-down arg)
    (org-return nil arg)))

(defun +org/insert-item-below (count)
  "Insert a new heading, table cell or item below the current one.
  `dotimes' COUNT, Universal operator.

  Stolen from Doom Emacs"
  (interactive "p")
  (dotimes (_ count) (+org--insert-item 'below)))

(defun +org/insert-item-above (count)
  "Insert a new heading, table cell or item above the current one.
  `dotimes' COUNT, Universal operator.

  Stolen from Doom Emacs"
  (interactive "p")
  (dotimes (_ count) (+org--insert-item 'above)))
#+end_src

** Language Support

#+begin_src emacs-lisp
(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)
   (python . t)))
(push '("conf-unix" . conf-unix) org-src-lang-modes)
#+end_src

Org can complete =<el[TAB]= into an empty elisp source block, here is where more of these shortcuts can be made.
#+begin_src emacs-lisp
(require 'org-tempo)
(add-to-list 'org-structure-template-alist '("sh" . "src shell"))
(add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
(add-to-list 'org-structure-template-alist '("py" . "src python"))
#+end_src

** Auto tangle
Automatically tangle org files inside the emacs configuration directory.

#+name: org-auto-tangle
#+begin_src emacs-lisp
(defun efs/org-babel-tangle-config ()
  "Detects if a file is in the Emacs config directory, and tangle."
  (when (string-equal (file-name-directory (buffer-file-name))
                      (expand-file-name "~/.config/emacs/"))
    ;; Dynamic scoping to the rescue
    (let ((org-confirm-babel-evaluate nil))
      (org-babel-tangle))))
#+end_src

** Agenda

~:custom~
#+name: org-agenda-custom
#+begin_src emacs-lisp :tangle no
(org-agenda-files
 '("~/Projects/Org/Tasks.org"
   "~/Projects/Org/Habits.org"
   "~/Projects/Org/Birthdays.org"))

(org-habit-graph-column 60)

(org-todo-keywords
 '((sequence "TODO(t)" "NEXT(n)" "|" "DONE(d!)")
   (sequence "BACKLOG(b)" "PLAN(p)" "READY(r)" "ACTIVE(a)" "REVIEW(v)" "WAIT(w@/!)" "HOLD(h)" "|" "COMPLETED(c)" "CANC(k@)")))

(org-refile-targets
 '(("Archive.org" :maxlevel . 1)
   ("Tasks.org" :maxlevel . 1)))

(org-tag-alist
 '((:startgroup)
                                        ; Put mutually exclusive tags here
   (:endgroup)
   ("@errand" . ?E)
   ("@home" . ?H)
   ("@work" . ?W)
   ("agenda" . ?a)
   ("planning" . ?p)
   ("publish" . ?P)
   ("batch" . ?b)
   ("note" . ?n)
   ("idea" . ?i)))

;; Configure custom agenda views
(org-agenda-custom-commands
 '(("d" "Dashboard"
    ((agenda "" ((org-deadline-warning-days 7)))
     (todo "NEXT"
           ((org-agenda-overriding-header "Next Tasks")))
     (tags-todo "agenda/ACTIVE" ((org-agenda-overriding-header "Active Projects")))))

   ("n" "Next Tasks"
    ((todo "NEXT"
           ((org-agenda-overriding-header "Next Tasks")))))

   ("W" "Work Tasks" tags-todo "+work-email")

   ;; Low-effort next actions
   ("e" tags-todo "+TODO=\"NEXT\"+Effort<15&+Effort>0"
    ((org-agenda-overriding-header "Low Effort Tasks")
     (org-agenda-max-todos 20)
     (org-agenda-files org-agenda-files)))

   ("w" "Workflow Status"
    ((todo "WAIT"
           ((org-agenda-overriding-header "Waiting on External")
            (org-agenda-files org-agenda-files)))
     (todo "REVIEW"
           ((org-agenda-overriding-header "In Review")
            (org-agenda-files org-agenda-files)))
     (todo "PLAN"
           ((org-agenda-overriding-header "In Planning")
            (org-agenda-todo-list-sublevels nil)
            (org-agenda-files org-agenda-files)))
     (todo "BACKLOG"
           ((org-agenda-overriding-header "Project Backlog")
            (org-agenda-todo-list-sublevels nil)
            (org-agenda-files org-agenda-files)))
     (todo "READY"
           ((org-agenda-overriding-header "Ready for Work")
            (org-agenda-files org-agenda-files)))
     (todo "ACTIVE"
           ((org-agenda-overriding-header "Active Projects")
            (org-agenda-files org-agenda-files)))
     (todo "COMPLETED"
           ((org-agenda-overriding-header "Completed Projects")
            (org-agenda-files org-agenda-files)))
     (todo "CANC"
           ((org-agenda-overriding-header "Cancelled Projects")
            (org-agenda-files org-agenda-files)))))))

(org-capture-templates
 `(("t" "Tasks / Projects")
   ("tt" "Task" entry (file+olp "~/Projects/Code/emacs-from-scratch/OrgFiles/Tasks.org" "Inbox")
    "* TODO %?\n  %U\n  %a\n  %i" :empty-lines 1)

   ("j" "Journal Entries")
   ("jj" "Journal" entry
    (file+olp+datetree "~/Projects/Code/emacs-from-scratch/OrgFiles/Journal.org")
    "\n* %<%I:%M %p> - Journal :journal:\n\n%?\n\n"
    ;; ,(dw/read-file-as-string "~/Notes/Templates/Daily.org")
    :clock-in :clock-resume
    :empty-lines 1)
   ("jm" "Meeting" entry
    (file+olp+datetree "~/Projects/Code/emacs-from-scratch/OrgFiles/Journal.org")
    "* %<%I:%M %p> - %a :meetings:\n\n%?\n\n"
    :clock-in :clock-resume
    :empty-lines 1)

   ("w" "Workflows")
   ("we" "Checking Email" entry (file+olp+datetree "~/Projects/Code/emacs-from-scratch/OrgFiles/Journal.org")
    "* Checking Email :email:\n\n%?" :clock-in :clock-resume :empty-lines 1)

   ("m" "Metrics Capture")
   ("mw" "Weight" table-line (file+headline "~/Projects/Code/emacs-from-scratch/OrgFiles/Metrics.org" "Weight")
    "| %U | %^{Weight} | %^{Notes} |" :kill-buffer t)))
#+end_src

~:config~
#+name: org-agenda-config
#+begin_src emacs-lisp
;; Save Org buffers after refiling!
(advice-add 'org-refile :after 'org-save-all-org-buffers)
#+end_src

** Prettyification
Prettify headings and items by using superstar.
#+begin_src emacs-lisp
(use-package org-superstar
  :after org
  :hook (org-mode . (lambda () (org-superstar-mode 1))))
#+end_src

** Exporters

*** Latex

- Links should be rendered without being surrounded by a red box.
#+name: org-export-latex-custom
#+begin_src emacs-lisp :tangle no
(org-latex-default-packages-alist
 '(("AUTO" "inputenc" t
    ("pdflatex"))
   ("T1" "fontenc" t
    ("pdflatex"))
   ("" "graphicx" t)
   ("" "grffile" t)
   ("" "longtable" nil)
   ("" "wrapfig" nil)
   ("" "rotating" nil)
   ("normalem" "ulem" t)
   ("" "amsmath" t)
   ("" "textcomp" t)
   ("" "amssymb" t)
   ("" "capt-of" nil)
   ("" "xcolor" nil)
   ("" "hyperref" nil)))
(org-latex-hyperref-template "\\hypersetup{
  pdfauthor={%a},
  pdftitle={%t},
  pdfkeywords={%k},
  pdfsubject={%d},
  pdfcreator={%c},
  pdflang={%L},
  colorlinks=true,
  linktoc=all,
  colorlinks=true,
  urlcolor=DodgerBlue4,
  citecolor=PaleGreen1,
  linkcolor=black}
  ")
#+end_src

*** Hugo

#+name: org-export-hugo-config
#+begin_src emacs-lisp :tangle no
(use-package ox-hugo)
#+end_src

*** Pandoc

#+name: org-export-pandoc-config
#+begin_src emacs-lisp :tangle no
(use-package ox-pandoc
  :when (executable-find "pandoc")
  :init
  (add-to-list 'org-export-backends 'pandoc)
  (setq org-pandoc-options
        '((standalone . t)
          (mathjax . t)
          (variable . "revealjs-url=https://revealjs.com"))))
#+end_src
*** Groff
#+name: org-export-groff-config
#+begin_src emacs-lisp :tangle no
(require 'ox-groff)
#+end_src
** Babel

#+name: org-babel-config
#+begin_src emacs-lisp :tangle no
(require 'ob-C)
#+end_src
* Email

#+begin_src emacs-lisp
(load-file "~/.config/emacs/lisp/email.el")

(blast/leader
  "om" '(mu4e :which-key "mailbox"))

;; start auto-syncing
(mu4e t) ;; TODO: Defer
#+end_src

* Utilities
** PDF Tools
Emacs' default pdf viewer leaves some to desired, but pdf-tools provides these... pdf, tools.

#+begin_src emacs-lisp
(use-package pdf-tools
  ;;waiting on politza/pdf-tools#588
  :straight `(pdf-tools
              :type git
              :host github
              :repo "flatwhatson/pdf-tools"
              :branch "fix-macros")
  :mode ("\\.[pP][dD][fF]\\'" . pdf-view-mode)
  :magic ("%PDF" . pdf-view-mode)
  :hook (pdf-view-mode-hook .
                            (lambda ()
                              (setq-local evil-normal-state-cursor (list nil))
                              (pdf-view-midnight-minor-mode t)))

  :bind (:map pdf-view-mode-map
              ("q" . kill-current-buffer))
  :config
  (setq-default pdf-view-display-size 'fit-page)
  (pdf-loader-install))
#+end_src

** Kde Connect
Until I get my Librem 5 with full convergence, I'll be wanting this for device integration.

#+begin_src emacs-lisp
(use-package kdeconnect
  :config
  (setq kdeconnect-devices "3d5ea0779190e177"
        kdeconnect-active-device "3d5ea0779190e177"))
#+end_src

* 
#+begin_src emacs-lisp :exports none
(provide 'init)
;;; init.el ends here
#+end_src
